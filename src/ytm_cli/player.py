# ytm-cli - YouTube Music CLI
# Created by Jack Elston
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
"""Audio playback using mpv with IPC control."""

import json
import shutil
import socket
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Any

EQ_FREQUENCIES = [32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000]


class Player:
    """Handle audio playback for YouTube Music tracks with IPC control."""

    def __init__(self) -> None:
        self._process: subprocess.Popen[bytes] | None = None
        self._socket_path: Path | None = None
        self._socket: socket.socket | None = None
        self._duration: float = 0
        self._check_dependencies()

    def _check_dependencies(self) -> None:
        """Check that required external tools are available."""
        if not shutil.which("mpv"):
            raise RuntimeError(
                "mpv is required for audio playback. "
                "Install it with: sudo apt install mpv (Ubuntu/Debian) "
                "or brew install mpv (macOS)"
            )

    def _update_cookies_file(self, headers_file: Path, cookies_file: Path) -> None:
        """Update cookies.txt from headers.json if headers is newer."""
        try:
            # Skip if cookies file is newer than headers file
            if cookies_file.exists():
                if cookies_file.stat().st_mtime >= headers_file.stat().st_mtime:
                    return

            with open(headers_file) as f:
                headers = json.load(f)

            cookie_str = headers.get("cookie", "")
            if not cookie_str:
                return

            lines = ["# Netscape HTTP Cookie File", "# Generated by ytm-cli", ""]
            for part in cookie_str.split("; "):
                if "=" in part:
                    name, value = part.split("=", 1)
                    secure = "TRUE" if name.startswith("__Secure") else "FALSE"
                    line = f".youtube.com\tTRUE\t/\t{secure}\t0\t{name}\t{value}"
                    lines.append(line)

            with open(cookies_file, "w") as f:
                f.write("\n".join(lines))
        except Exception:
            pass

    def _connect_ipc(self) -> bool:
        """Connect to mpv IPC socket."""
        if not self._socket_path or not self._socket_path.exists():
            return False

        try:
            self._socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self._socket.settimeout(1.0)
            self._socket.connect(str(self._socket_path))
            return True
        except OSError:
            self._socket = None
            return False

    def _send_command(self, command: list[Any]) -> dict[str, Any] | None:
        """Send a command to mpv via IPC and get response."""
        if not self._socket:
            if not self._connect_ipc():
                return None

        try:
            msg = json.dumps({"command": command}) + "\n"
            self._socket.sendall(msg.encode())  # type: ignore

            buf = b""
            while True:
                chunk = self._socket.recv(4096)  # type: ignore
                if not chunk:
                    break
                buf += chunk
                # Process complete lines; mpv sends async event lines
                # before the command response, so skip those.
                while b"\n" in buf:
                    line, buf = buf.split(b"\n", 1)
                    parsed = json.loads(line)
                    if "error" in parsed:
                        return parsed
        except (json.JSONDecodeError, OSError):
            self._socket = None
        return None

    def _get_property(self, name: str) -> Any:
        """Get an mpv property value."""
        result = self._send_command(["get_property", name])
        if result and "data" in result:
            return result["data"]
        return None

    def _set_property(self, name: str, value: Any) -> bool:
        """Set an mpv property value."""
        result = self._send_command(["set_property", name, value])
        return result is not None and result.get("error") == "success"

    def play(self, video_id: str) -> float:
        """Play audio for a given video ID.

        Returns:
            Duration of the track in seconds.
        """
        self.stop()

        url = f"ytdl://{video_id}"

        # Create IPC socket path
        self._socket_path = Path(tempfile.mktemp(suffix=".sock", prefix="ytm-mpv-"))

        # Build mpv command - stream directly
        cmd = [
            "mpv",
            "--no-video",
            "--no-terminal",
            f"--input-ipc-server={self._socket_path}",
        ]

        # Add cookie authentication and JS runtime for yt-dlp
        config_dir = Path.home() / ".config" / "ytm-cli"
        cookies_file = config_dir / "cookies.txt"
        headers_file = config_dir / "headers.json"

        # Generate/update cookies.txt from headers.json
        if headers_file.exists():
            self._update_cookies_file(headers_file, cookies_file)

        if not cookies_file.exists():
            raise RuntimeError("Not authenticated. Run 'ytm auth' first.")

        cmd.append(f"--ytdl-raw-options=js-runtimes=node,cookies={cookies_file}")

        cmd.append(url)

        # Play with mpv (it uses yt-dlp internally)
        self._process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

        # Wait for socket to be created
        for i in range(50):  # Wait up to 5 seconds for socket
            if self._socket_path.exists():
                break
            # Check if process died
            if self._process.poll() is not None:
                raise RuntimeError("mpv failed to start. Try running 'ytm auth' to authenticate.")
            time.sleep(0.1)
        else:
            if self._process.poll() is not None:
                raise RuntimeError("mpv failed to start. Try running 'ytm auth' to authenticate.")
            raise RuntimeError("mpv socket not created")

        # Connect to IPC
        for i in range(20):  # Wait up to 2 seconds for IPC connection
            if self._connect_ipc():
                break
            if self._process.poll() is not None:
                raise RuntimeError("mpv process died")
            time.sleep(0.1)

        # Duration will be fetched later when available
        return 0

    def stop(self) -> None:
        """Stop current playback."""
        if self._socket:
            try:
                self._socket.close()
            except Exception:
                pass
            self._socket = None

        if self._process:
            self._process.terminate()
            try:
                self._process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self._process.kill()
            self._process = None

        if self._socket_path and self._socket_path.exists():
            try:
                self._socket_path.unlink()
            except Exception:
                pass
            self._socket_path = None

        self._duration = 0

    def is_playing(self) -> bool:
        """Check if audio is currently playing (not paused and process running)."""
        if self._process and self._process.poll() is None:
            paused = self._get_property("pause")
            return paused is False
        return False

    def is_active(self) -> bool:
        """Check if player process is running (playing or paused)."""
        return self._process is not None and self._process.poll() is None

    def toggle_pause(self) -> bool:
        """Toggle pause state. Returns new pause state."""
        current = self._get_property("pause")
        if current is not None:
            new_state = not current
            self._set_property("pause", new_state)
            return new_state
        return False

    def pause(self) -> None:
        """Pause playback."""
        self._set_property("pause", True)

    def resume(self) -> None:
        """Resume playback."""
        self._set_property("pause", False)

    def get_position(self) -> float:
        """Get current playback position in seconds."""
        pos = self._get_property("time-pos")
        return float(pos) if pos is not None else 0.0

    def get_duration(self) -> float:
        """Get track duration in seconds."""
        # Try to get from mpv first (more accurate)
        dur = self._get_property("duration")
        if dur is not None:
            return float(dur)
        return self._duration

    def get_progress(self) -> tuple[float, float]:
        """Get current position and duration.

        Returns:
            Tuple of (position, duration) in seconds.
        """
        return self.get_position(), self.get_duration()

    def seek(self, seconds: float, relative: bool = True) -> None:
        """Seek in the current track.

        Args:
            seconds: Seconds to seek (positive = forward, negative = backward)
            relative: If True, seek relative to current position
        """
        mode = "relative" if relative else "absolute"
        self._send_command(["seek", seconds, mode])

    def set_volume(self, volume: int) -> None:
        """Set volume (0-100)."""
        self._set_property("volume", max(0, min(100, volume)))

    def get_volume(self) -> int:
        """Get current volume (0-100)."""
        vol = self._get_property("volume")
        return int(vol) if vol is not None else 100

    def get_audio_devices(self) -> list[dict[str, str]]:
        """Get list of available audio output devices.

        Returns only auto + PulseAudio/PipeWire sinks (filters out raw ALSA).
        """
        devices = self._get_property("audio-device-list")
        if not devices:
            return []
        return [
            {"name": d["name"], "description": d["description"]}
            for d in devices
            if d["name"] == "auto" or d["name"].startswith("pulse/")
        ]

    def get_audio_device(self) -> str:
        """Get current audio output device name."""
        return self._get_property("audio-device") or "auto"

    def set_audio_device(self, name: str) -> bool:
        """Switch audio output device live and set as system default."""
        result = self._set_property("audio-device", name)
        # Set as system default so hardware volume keys follow
        if name.startswith("pulse/"):
            sink = name[len("pulse/") :]
            subprocess.run(["pactl", "set-default-sink", sink], capture_output=True)
        return result

    def set_equalizer(self, bands: list[float]) -> bool:
        """Apply a 10-band equalizer via lavfi audio filters.

        Args:
            bands: 10 gain values in dB (-12 to +12), one per EQ_FREQUENCIES band.
        """
        if len(bands) != len(EQ_FREQUENCIES):
            return False
        parts = []
        for freq, gain in zip(EQ_FREQUENCIES, bands):
            gain = max(-12.0, min(12.0, gain))
            parts.append(f"equalizer=f={freq}:width_type=o:w=1.4:g={gain}")
        chain = ",".join(parts)
        result = self._send_command(["af", "set", f"lavfi=[{chain}]"])
        return result is not None and result.get("error") == "success"

    def clear_equalizer(self) -> bool:
        """Remove all audio filters."""
        result = self._send_command(["af", "set", ""])
        return result is not None and result.get("error") == "success"

    @staticmethod
    def get_pulse_volume() -> int:
        """Get PulseAudio default sink volume (0-150)."""
        try:
            result = subprocess.run(
                ["pactl", "get-sink-volume", "@DEFAULT_SINK@"],
                capture_output=True,
                text=True,
                timeout=2,
            )
            # Output like: "Volume: front-left: 65536 / 100% / ..."
            for part in result.stdout.split("/"):
                part = part.strip()
                if part.endswith("%"):
                    return int(part[:-1])
        except Exception:
            pass
        return 100

    @staticmethod
    def set_pulse_volume(vol: int) -> None:
        """Set PulseAudio default sink volume (0-150)."""
        vol = max(0, min(150, vol))
        subprocess.run(
            ["pactl", "set-sink-volume", "@DEFAULT_SINK@", f"{vol}%"],
            capture_output=True,
            timeout=2,
        )

    @staticmethod
    def toggle_pulse_mute() -> None:
        """Toggle PulseAudio default sink mute."""
        subprocess.run(
            ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "toggle"],
            capture_output=True,
            timeout=2,
        )

    @staticmethod
    def get_pulse_mute() -> bool:
        """Check if PulseAudio default sink is muted."""
        try:
            result = subprocess.run(
                ["pactl", "get-sink-mute", "@DEFAULT_SINK@"],
                capture_output=True,
                text=True,
                timeout=2,
            )
            return "yes" in result.stdout.lower()
        except Exception:
            return False

    def seek_absolute(self, position: float) -> None:
        """Seek to an absolute position in seconds."""
        self.seek(position, relative=False)

    def wait(self) -> None:
        """Wait for current track to finish playing."""
        if self._process:
            self._process.wait()
